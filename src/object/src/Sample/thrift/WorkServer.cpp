// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include "WorkService.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>

#include <iostream>
#include <boost/make_shared.hpp>
#include <thrift/transport/TSocket.h>
#include <thrift/server/TThreadPoolServer.h>
#include <thrift/concurrency/ThreadManager.h>
#include <thrift/concurrency/PlatformThreadFactory.h>

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;
using namespace ::apache::thrift::concurrency;

using boost::shared_ptr;

using namespace ::test;
using namespace ::std;

class WorkServiceHandler : virtual public WorkServiceIf {
 public:
  WorkServiceHandler() {
    // Your initialization goes here
  }

  int32_t ping(const int32_t value) {
    // Your implementation goes here
    printf("ping: %d\n", value);
    return value + 1;
  }

  void trigger(WorkTask& _return, const int64_t seqno, const WorkTask& task) {
    // Your implementation goes here
    printf("trigger: seqno %d, task: %s \n", (int32_t)seqno, task.Vstr.c_str());
    _return.V64 = seqno + 1;
    _return.Vstr = "[" + task.Vstr + "]";
  }

};

class WorkServiceFactory : virtual public WorkServiceIfFactory {
 public:
  virtual ~WorkServiceFactory() {}

  virtual WorkServiceIf* getHandler(const ::apache::thrift::TConnectionInfo& connInfo) {
	boost::shared_ptr<TSocket> sock = boost::dynamic_pointer_cast<TSocket>(connInfo.transport);
	cout << "Incoming connection\n";
	cout << "\tSocketInfo: "  << sock->getSocketInfo() << "\n";
	cout << "\tPeerHost: "    << sock->getPeerHost() << "\n";
	cout << "\tPeerAddress: " << sock->getPeerAddress() << "\n";
	cout << "\tPeerPort: "    << sock->getPeerPort() << "\n";
	return new WorkServiceHandler;
  }
  virtual void releaseHandler(WorkServiceIf* handler) {
	  delete handler;
  }
};

int main(int argc, char **argv) {
  int port = 9090;

  boost::shared_ptr<ThreadManager> threadmanager = ThreadManager::newSimpleThreadManager(2);
  threadmanager->threadFactory(boost::make_shared<PlatformThreadFactory>());
  threadmanager->start();

  TThreadPoolServer server(
//	boost::make_shared<WorkServiceProcessor>(boost::make_shared<WorkServiceHandler>()),
	boost::make_shared<WorkServiceProcessorFactory>(boost::make_shared<WorkServiceFactory>()),
	boost::make_shared<TServerSocket>(port),
	boost::make_shared<TBufferedTransportFactory>(),
	boost::make_shared<TBinaryProtocolFactory>(),
	threadmanager);

  cout << "Starting the server..." << endl;
  server.serve();
  cout << "Done." << endl;
  return 0;
}

